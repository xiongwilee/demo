<!doctype html>
<html>

<head>
  <title>方块拼图</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,user-scalable=no">
  <style>
    label {
      display: block;
    }

    textarea {
      font-family: monospace;
      min-width: 500px;
      min-height: 100px;
    }
  </style>
  <script type="text/javascript">
    class BlockPuzzle {
      constructor(land, blocks) {
        this.land = land
        this.blocks = blocks
        this.matrixTranBuffer = {}
      }
      validator() {
        if (!this.is2Darr(this.land)) {
          throw `land 字段不合法：${JSON.stringify(this.land)}`
        }

        const isBlocksVerify = this.blocks.every(item => this.is2Darr(item))
        if (!isBlocksVerify) {
          throw `blocks 字段不合法：${JSON.stringify(this.blocks)}`
        }
      }
      /**
       * block和land必须是一个标准的二维矩阵
       */
      is2Darr(arr) {
        if (!Array.isArray(arr)) return false

        return arr.every(item => {
          return Array.isArray(arr[0]) && item.length == arr[0].length
        })
      }
      puzzle() {
        this.validator()

        return this.permutation(this.blocks, (bloList) => {
          return this.puzzleSingle(bloList)
        })
      }
      /**
       * 计算带block列表能不能完成拼图
       */
      puzzleSingle(blocks) {
        const newBlocks = []

        for (let i = 0; i < blocks.length; i++) {
          newBlocks.push(this.transMatrix(blocks[i]))
        }

        return this.descartesUtil(newBlocks, (resultBlock) => {
          let resultLand = this.copy(this.land)
          for (let i = 0; i < resultBlock.length; i++) {
            // 如果i==1 则将 [[0,1],[1,1]] 转成 [[0,2],[2,2]] 方便后续标记
            let curBlock = resultBlock[i].map(item => {
              return item.map(subItem => subItem * (1 + i))
            })
            
            resultLand = this.mergeMatrix(curBlock, resultLand)
            if (!resultLand) return false
          }
          return { resultBlock , resultLand}
        })
      }
      /**
       * 数组深拷贝
       * @param {Array}
       * @return {Array}
       **/
      copy(arr) {
        return times(arr)

        function times(arr) {
          let result = []
          for (let i = 0; i < arr.length; i++) {
            if (Array.isArray(arr[i])) {
              result.push(times(arr[i]))
            } else {
              result.push(arr[i])
            }
          }
          return result
        }
      }
      mergeMatrix(block, land) {
        const curLand = this.copy(land)

        // 获取左下角第一个不为0的坐标
        const landCoo = this.findLandCoo(curLand)
        const blockCoo = this.findBlockCoo(block)

        // 计算整体偏移量
        const offsetXY = [landCoo[0] - blockCoo[0], landCoo[1] - blockCoo[1]]

        // 排除不合法的偏移
        if (offsetXY[0] < 0 || offsetXY[1] < 0) return false
        if (block.length + offsetXY[0] > curLand.length) return false
        if (block[0].length + offsetXY[1] > curLand[0].length) return false

        // 碰撞检测
        for (let i = 0; i < block.length; i++) {
          for (let j = 0; j < block[i].length; j++) {
            let offsetX = i + offsetXY[0]
            let offsetY = j + offsetXY[1]

            // 碰撞检测，如果两者全大于0，则发生碰撞
            if (!!curLand[offsetX][offsetY] && !!block[i][j]) return false

            curLand[offsetX][offsetY] = curLand[offsetX][offsetY] + block[i][j]
          }
        }

        return curLand
      }
      /**
       * 找到land左下角第一个为零元素的坐标
       * @return Array
       */
      findLandCoo(arr) {
        for (let i = 0; i < arr.length; i++) {
          for (let j = 0; j < arr[i].length; j++) {
            if (arr[i][j] == 0) return [i, j]
          }
        }
      }
      /**
       * 找到block左下角第一非为零元素的坐标
       * @return Array
       */
      findBlockCoo(arr) {
        for (let i = 0; i < arr.length; i++) {
          for (let j = 0; j < arr[i].length; j++) {
            if (arr[i][j] > 0) return [i, j]
          }
        }
      }
      /**
       * 获取二位数组（二位矩阵）在二维平面旋转之后的结果集
       * @return Array
       **/
      transMatrix(matrix) {
        const matrixSer = JSON.stringify(matrix)
        if (this.matrixTranBuffer[matrixSer]) return this.matrixTranBuffer[matrixSer]

        const resultObj = { matrixSer: matrix }

        // 上下翻转
        const upAndDown = this.copy(matrix).reverse()
        resultObj[JSON.stringify(upAndDown)] = upAndDown

        // 左右翻转
        const leftAndRight = matrix.map((item) => this.copy(item).reverse())
        resultObj[JSON.stringify(leftAndRight)] = leftAndRight

        // 上下左右翻转（旋转180度）
        const turn180 = this.copy(leftAndRight).reverse()
        resultObj[JSON.stringify(turn180)] = turn180

        // 顺时针90度后上下翻转
        const turn90AndUpdown = []
        this.copy(matrix).map((item, i) => {
          item.map((subItem, j) => {
            turn90AndUpdown[j] = turn90AndUpdown[j] || []
            turn90AndUpdown[j][i] = subItem
          })
        })
        resultObj[JSON.stringify(turn90AndUpdown)] = turn90AndUpdown

        // 顺时针90度后上下翻转后左右翻转(翻转90度)
        const turn90 = this.copy(turn90AndUpdown).reverse()
        resultObj[JSON.stringify(turn90)] = turn90

        // 翻转270度
        const turn270 = turn90AndUpdown.map((item) => this.copy(item).reverse())
        resultObj[JSON.stringify(turn270)] = turn270

        // 上下翻转后旋转90度
        const updownAndturn90 = this.copy(turn270).reverse()
        resultObj[JSON.stringify(updownAndturn90)] = updownAndturn90

        const result = [];

        Object.keys(resultObj).map((i) => {
          result.push(resultObj[i])
          this.matrixTranBuffer[i] = result
        })

        return result
      }
      /**
       * 全排列算法：传入一个数组，计算所有可能的排列组合，在回调中逐一执行
       * @param {Array}   arr      默认数组
       * @param {Function} 
       */
      permutation(arr, callback) {
        let result = []
        let flag = true

        return times(arr, result)

        function times(arr, result) {
          let length = arr.length

          if (!flag) return false
          if (length == 0) {
            let callbackRes = callback && callback(result)

            if (!!callbackRes) {
              flag = false
              return callbackRes
            }
            return false
          }

          for (let i = 0; i < length; i++) {
            let newArr = arr.slice()
            newArr.splice(i, 1)

            let newResult = [].concat(result, [arr[i]])
            let callRes = times(newArr, newResult)
            if (!!callRes) return callRes
          }

          return false
        }
      }
      /**
       * 笛卡尔积算法：传入N个数组，计算所有可能的排列组合，在回调中逐一执行
       * @param {Array}   arr      默认数组
       * @param {Function} 
       */
      descartesUtil(arr, callback) {
        let result = []
        let flag = true

        return times(arr, result)

        function times(arr, result) {
          let length = arr.length

          if (!flag) return false
          if (length == 0) {
            let callbackRes = callback && callback(result)

            if (!!callbackRes) {
              flag = false
              return callbackRes
            }
            return false
          }

          let curArr = arr[0]
          for (let i = 0; i < curArr.length; i++) {
            let newResult = [].concat(result, [curArr[i]])
            let callRes = times(arr.slice(1), newResult)
            if (!!callRes) return callRes
          }

          return false
        }
      }
    }
  </script>
</head>

<body>
  <div>
    <h3>俄罗斯方块拼图实现</h3>
  </div>

  <form>
    <div>
      <label>方块列表</label>
      <textarea type="text"
        id="blockList">[[[1,1],[0,1]], [[1],[1],[1]], [[1],[1]], [[1,0],[1,1],[1,0]], [[0,0,1],[1,1,1]]]</textarea>
    </div>
    <div>
      <label>棋盘</label>
      <textarea type="text" id="land">[[0,0,0,0], [0,0,0,0], [0,0,0,0], [0,0,0,0]]</textarea>
    </div>
    <div>
      <input type="button" id="button" value="提交">
    </div>
  </form>
  <div id="result" style="display: none;">
    <div>
      <label>分配顺序：</label>
      <textarea id="result_list"></textarea>
    </div>
    <div>
      <label>示例：</label>
      <textarea id="result_example"></textarea>
    </div>
  </div>

  <script type="text/javascript">
    document.getElementById('button').addEventListener('click', function () {
      const blockList = document.getElementById('blockList').value
      const land = document.getElementById('land').value

      const blockPuzzle = new BlockPuzzle(JSON.parse(land), JSON.parse(blockList))

      const result = blockPuzzle.puzzle()
      if (!result) {
        document.getElementById('result').style.display = 'none'
        return alert('找不到合理的拼图方案')
      }

      document.getElementById('result').style.display = 'block'
      document.getElementById('result_list').value = JSON.stringify(result.resultBlock)
      document.getElementById('result_example').value = JSON.stringify(result.resultLand.reverse())
    })
  </script>
</body>

</html>