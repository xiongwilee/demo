<h1 id="minimatch">minimatch</h1>
<p>A minimal matching utility.</p>
<p><a href="http://travis-ci.org/isaacs/minimatch"><img src="https://secure.travis-ci.org/isaacs/minimatch.png" alt="Build Status"></a></p>
<p>This is the matching library used internally by npm.</p>
<p>Eventually, it will replace the C binding in node-glob.</p>
<p>It works by converting glob expressions into JavaScript <code>RegExp</code><br>objects.</p>
<h2 id="Usage">Usage</h2>
<pre><code class="javascript"><span class="keyword">var</span> minimatch = <span class="built_in">require</span>(<span class="string">"minimatch"</span>)

minimatch(<span class="string">"bar.foo"</span>, <span class="string">"*.foo"</span>) <span class="comment">// true!</span>
minimatch(<span class="string">"bar.foo"</span>, <span class="string">"*.bar"</span>) <span class="comment">// false!</span>
minimatch(<span class="string">"bar.foo"</span>, <span class="string">"*.+(bar|foo)"</span>, { debug: <span class="literal">true</span> }) <span class="comment">// true, and noisy!</span>
</code></pre>
<h2 id="Features">Features</h2>
<p>Supports these glob features:</p>
<ul>
<li>Brace Expansion</li>
<li>Extended glob matching</li>
<li>“Globstar” <code>**</code> matching</li>
</ul>
<p>See:</p>
<ul>
<li><code>man sh</code></li>
<li><code>man bash</code></li>
<li><code>man 3 fnmatch</code></li>
<li><code>man 5 gitignore</code></li>
</ul>
<h2 id="Minimatch_Class">Minimatch Class</h2>
<p>Create a minimatch object by instanting the <code>minimatch.Minimatch</code> class.</p>
<pre><code class="javascript"><span class="keyword">var</span> Minimatch = <span class="built_in">require</span>(<span class="string">"minimatch"</span>).Minimatch
<span class="keyword">var</span> mm = <span class="keyword">new</span> Minimatch(pattern, options)
</code></pre>
<h3 id="Properties">Properties</h3>
<ul>
<li><code>pattern</code> The original pattern the minimatch object represents.</li>
<li><code>options</code> The options supplied to the constructor.</li>
<li><p><code>set</code> A 2-dimensional array of regexp or string expressions.<br>Each row in the<br>array corresponds to a brace-expanded pattern.  Each item in the row<br>corresponds to a single path-part.  For example, the pattern<br><code>{a,b/c}/d</code> would expand to a set of patterns like:</p>
<pre><code>  [ [ a, d ]
  , [ b, c, d ] ]
</code></pre><p>  If a portion of the pattern doesn’t have any “magic” in it<br>  (that is, it’s something like <code>&quot;foo&quot;</code> rather than <code>fo*o?</code>), then it<br>  will be left as a string rather than converted to a regular<br>  expression.</p>
</li>
<li><p><code>regexp</code> Created by the <code>makeRe</code> method.  A single regular expression<br>expressing the entire pattern.  This is useful in cases where you wish<br>to use the pattern somewhat like <code>fnmatch(3)</code> with <code>FNM_PATH</code> enabled.</p>
</li>
<li><code>negate</code> True if the pattern is negated.</li>
<li><code>comment</code> True if the pattern is a comment.</li>
<li><code>empty</code> True if the pattern is <code>&quot;&quot;</code>.</li>
</ul>
<h3 id="Methods">Methods</h3>
<ul>
<li><code>makeRe</code> Generate the <code>regexp</code> member if necessary, and return it.<br>Will return <code>false</code> if the pattern is invalid.</li>
<li><code>match(fname)</code> Return true if the filename matches the pattern, or<br>false otherwise.</li>
<li><code>matchOne(fileArray, patternArray, partial)</code> Take a <code>/</code>-split<br>filename, and match it against a single row in the <code>regExpSet</code>.  This<br>method is mainly for internal use, but is exposed so that it can be<br>used by a glob-walker that needs to avoid excessive filesystem calls.</li>
</ul>
<p>All other methods are internal, and will be called as necessary.</p>
<h2 id="Functions">Functions</h2>
<p>The top-level exported function has a <code>cache</code> property, which is an LRU<br>cache set to store 100 items.  So, calling these methods repeatedly<br>with the same pattern and options will use the same Minimatch object,<br>saving the cost of parsing it multiple times.</p>
<h3 id="minimatch(path,_pattern,_options)">minimatch(path, pattern, options)</h3>
<p>Main export.  Tests a path against the pattern using the options.</p>
<pre><code class="javascript"><span class="keyword">var</span> isJS = minimatch(file, <span class="string">"*.js"</span>, { matchBase: <span class="literal">true</span> })
</code></pre>
<h3 id="minimatch-filter(pattern,_options)">minimatch.filter(pattern, options)</h3>
<p>Returns a function that tests its<br>supplied argument, suitable for use with <code>Array.filter</code>.  Example:</p>
<pre><code class="javascript"><span class="keyword">var</span> javascripts = fileList.filter(minimatch.filter(<span class="string">"*.js"</span>, {matchBase: <span class="literal">true</span>}))
</code></pre>
<h3 id="minimatch-match(list,_pattern,_options)">minimatch.match(list, pattern, options)</h3>
<p>Match against the list of<br>files, in the style of fnmatch or glob.  If nothing is matched, and<br>options.nonull is set, then return a list containing the pattern itself.</p>
<pre><code class="javascript"><span class="keyword">var</span> javascripts = minimatch.match(fileList, <span class="string">"*.js"</span>, {matchBase: <span class="literal">true</span>}))
</code></pre>
<h3 id="minimatch-makeRe(pattern,_options)">minimatch.makeRe(pattern, options)</h3>
<p>Make a regular expression object from the pattern.</p>
<h2 id="Options">Options</h2>
<p>All options are <code>false</code> by default.</p>
<h3 id="debug">debug</h3>
<p>Dump a ton of stuff to stderr.</p>
<h3 id="nobrace">nobrace</h3>
<p>Do not expand <code>{a,b}</code> and <code>{1..3}</code> brace sets.</p>
<h3 id="noglobstar">noglobstar</h3>
<p>Disable <code>**</code> matching against multiple folder names.</p>
<h3 id="dot">dot</h3>
<p>Allow patterns to match filenames starting with a period, even if<br>the pattern does not explicitly have a period in that spot.</p>
<p>Note that by default, <code>a/**/b</code> will <strong>not</strong> match <code>a/.d/b</code>, unless <code>dot</code><br>is set.</p>
<h3 id="noext">noext</h3>
<p>Disable “extglob” style patterns like <code>+(a|b)</code>.</p>
<h3 id="nocase">nocase</h3>
<p>Perform a case-insensitive match.</p>
<h3 id="nonull">nonull</h3>
<p>When a match is not found by <code>minimatch.match</code>, return a list containing<br>the pattern itself.  When set, an empty list is returned if there are<br>no matches.</p>
<h3 id="matchBase">matchBase</h3>
<p>If set, then patterns without slashes will be matched<br>against the basename of the path if it contains slashes.  For example,<br><code>a?b</code> would match the path <code>/xyz/123/acb</code>, but not <code>/xyz/acb/123</code>.</p>
<h3 id="nocomment">nocomment</h3>
<p>Suppress the behavior of treating <code>#</code> at the start of a pattern as a<br>comment.</p>
<h3 id="nonegate">nonegate</h3>
<p>Suppress the behavior of treating a leading <code>!</code> character as negation.</p>
<h3 id="flipNegate">flipNegate</h3>
<p>Returns from negate expressions the same as if they were not negated.<br>(Ie, true on a hit, false on a miss.)</p>
<h2 id="Comparisons_to_other_fnmatch/glob_implementations">Comparisons to other fnmatch/glob implementations</h2>
<p>While strict compliance with the existing standards is a worthwhile<br>goal, some discrepancies exist between minimatch and other<br>implementations, and are intentional.</p>
<p>If the pattern starts with a <code>!</code> character, then it is negated.  Set the<br><code>nonegate</code> flag to suppress this behavior, and treat leading <code>!</code><br>characters normally.  This is perhaps relevant if you wish to start the<br>pattern with a negative extglob pattern like <code>!(a|B)</code>.  Multiple <code>!</code><br>characters at the start of a pattern will negate the pattern multiple<br>times.</p>
<p>If a pattern starts with <code>#</code>, then it is treated as a comment, and<br>will not match anything.  Use <code>\#</code> to match a literal <code>#</code> at the<br>start of a line, or set the <code>nocomment</code> flag to suppress this behavior.</p>
<p>The double-star character <code>**</code> is supported by default, unless the<br><code>noglobstar</code> flag is set.  This is supported in the manner of bsdglob<br>and bash 4.1, where <code>**</code> only has special significance if it is the only<br>thing in a path part.  That is, <code>a/**/b</code> will match <code>a/x/y/b</code>, but<br><code>a/**b</code> will not.</p>
<p>If an escaped pattern has no matches, and the <code>nonull</code> flag is set,<br>then minimatch.match returns the pattern as-provided, rather than<br>interpreting the character escapes.  For example,<br><code>minimatch.match([], &quot;\\*a\\?&quot;)</code> will return <code>&quot;\\*a\\?&quot;</code> rather than<br><code>&quot;*a?&quot;</code>.  This is akin to setting the <code>nullglob</code> option in bash, except<br>that it does not resolve escaped pattern characters.</p>
<p>If brace expansion is not disabled, then it is performed before any<br>other interpretation of the glob pattern.  Thus, a pattern like<br><code>+(a|{b),c)}</code>, which would not be valid in bash or zsh, is expanded<br><strong>first</strong> into the set of <code>+(a|b)</code> and <code>+(a|c)</code>, and those patterns are<br>checked for validity.  Since those two are valid, matching proceeds.</p>
